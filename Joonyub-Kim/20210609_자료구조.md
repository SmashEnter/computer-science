## **[1) malloc과 포인터 복습](https://www.boostcourse.org/cs112/lecture/119036?isDesc=false)**

> 배경

    C로 구현할 수 있는 다양한 데이터 구조를 배우게 된다. 데이터 구조를 정의하고 관리하는데 있어서 메모리와 포인터에 대한 개념을 정확히 이해하는 것이 중요하다. 먼저 지난 시간에 배운 malloc 함수와 포인터를 복습할 수 있는 예제를 살펴본다.

> 목표

    포인터의 개념과 malloc 함수의 용법을 잘 이해

> 키워드

    - 포인터
    - malloc

<br>

> 포인터

```c
int main(void)
{
    int *x;
    int *y;

    x = malloc(sizeof(int));

    *x = 42;
    *y = 13;
}
```

main 함수 안의 첫 두 줄 : **포인터 x와 y**를 선언

x : **malloc** 함수 이용, int 크기의 메모리를 할당

x와 y 포인터가 가리키는 지점에 각각 42와 13을 저장

**`*y = 13`** 

y는 포인터로만 선언되었을 뿐이지, 어디를 가리킬지에 대해서는 아직 정의가 되지 않은 상황

**초기화 되지 않은 *y**는 프로그램 어딘가를 임의로 가리키고 있을 수도 있음

따라서 그 곳에 13이라는 값을 저장하는 것이 오류를 발생시킬 수도 있는 것이죠.

**y = x; 를 써줌으로써**  y와 x는 동일한곳 가리키게 됨

*y = 13; 으로 저장하면  x가 가리키는 곳에도 동일하게 13으로 저장될 것

> 참고자료

- 자료구조 강의자료 - [https://www.boostcourse.org/downloadFile/fileDownload?attachmentId=525463&autoClose=true](https://www.boostcourse.org/downloadFile/fileDownload?attachmentId=525463&autoClose=true)

<br><br>

## **[2) 배열의 크기 조정하기](https://www.boostcourse.org/cs112/lecture/119037?isDesc=false)**

> 배경

    컴퓨터 안의 메모리는 마치 사물함과 같은 구조이다. 우리가 사용하고자 하는 사물함의 개수를 한 번 정한 이후에는, 공간이 모자란다고 해서 주변의 사물함을 마음대로 더 사용할 수는 없다. 이미 다른 목적으로 사용되고 있을 수도 있기 때문이다. 이와 같이 이미 일정한 크기의 메모리가 할당되어 있는 상황에서, 그 크기를 늘리는 일은 생각만큼 단순하지는 않다. 이번 강의에서는 포인터와 malloc의 개념을 응용해서, 이미 정의된 배열의 크기를 바꿔보도록 한다.

> 목표

    배열의 크기를 조정하는 코드를 작성할 수 있습니다.

> 키워드

    - malloc
    - realloc

한번 초기화된 배열의 크기를 재정의하고싶을 때

일정한 크기의 배열이 주어졌을 때, 그 크기를 키우려면?

단순하게 현재 배열이 저장되어 있는 메모리 위치의 바로 옆에 일정 크기의 메모리를 더 덧붙이면 되겠지만, 실제로는 다른 데이터가 저장되어 있을 확률이 높다.

→ 안전하게 **`새로운 공간에 큰 크기의 메모리를 다시 할당`**하고 기존 배열의 값들을 하나씩 옮겨줘야

따라서 이런 작업은 **`O(n)`**, 즉 배열의 크기 n만큼의 실행 시간이 소요될 것

> malloc()

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    //int 자료형 3개로 이루어진 list 라는 포인터를 선언하고 메모리 할당
    int *list = malloc(3 * sizeof(int));

    // 포인터가 잘 선언되었는지 확인
    if (list == NULL)
    {
        return 1;
    }

    // list 배열의 각 인덱스에 값 저장
    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    //int 자료형 4개 크기의 tmp 라는 포인터를 선언하고 메모리 할당
    int *tmp = malloc(4 * sizeof(int));

    if (tmp == NULL)
    {
        return 1;
    }

    // list의 값을 tmp로 복사
    for (int i = 0; i < 3; i++)
    {
        tmp[i] = list[i];
    }

    // tmp배열의 네 번째 값도 저장
    tmp[3] = 4;

    // list의 메모리를 초기화
    free(list);

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 배열 list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    // list의 메모리 초기화
    free(list);
}
```
<br>

> realloc()

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    // tmp 포인터에 메모리를 할당하고 list의 값 복사
    int *tmp = realloc(list, 4 * sizeof(int));
    if (tmp == NULL)
    {
        return 1;
    }

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 list의 네 번째 값 저장
    list[3] = 4;

    // list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    //list 의 메모리 초기화
    free(list);
}
```

<br><br>

## **[3) 연결 리스트: 도입](https://www.boostcourse.org/cs112/lecture/119038?isDesc=false)**

> 배경

    우리는 여러 자료형의 데이터를 메모리 상에 저장하고 읽고 삭제하는 방법을 배웠다. 컴퓨터 프로그램은 이러한 데이터를 이용해서 다양한 작업을 수행할 수 있다. 하지만 좀 더 복잡한 프로그램을 구현하다 보면 기본적인 포인터 구조만 이용해서 메모리를 관리하기에는 다소 번거로울 때가 많다. 만약 메모리를 좀 더 효율적으로 관리하고 사용할 수 있다면 어떨까? 이번 강의에서는 데이터 구조의 개념과 연결 리스트에 대해 알아본다.

> 목표

    연결 리스트의 정의를 설명

> 키워드

    - 연결 리스트

<br>

> 데이터구조

우리가 컴퓨터 메모리를 더 효율적으로 관리하기 위해 새로 정의하는 구조체

일종의 메모리 레이아웃, 또는 지도

종류로는 연결리스트, 해시테이블, 스택, 큐, 딕셔너리 등이 있다.

<br>

> 연결리스트(Linked List) _ Intro

각 값이 메모리상의 여러 군데 나뉘어져 있다고 하더라도 바로 다음 값의 메모리 주소만 기억하고 있다면 여전히 값을 연이어서 읽어들일 수 있는 구조

```c
typedef struct node
{
    int number;
    struct node *next;
}
node;
```

node 라는 이름의 구조체

- number 와 *next  두 개의 필드

number :  **각 node가 가지는 값**, 

*next : **다음 node를 가리키는 포인터**

여기서 typedef struct 대신에 typedef struct node 라고 ‘node’를 함께 명시해 주는 것은, 구조체 안에서 node를 사용하기 위함

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27e78079-a16e-4083-b8fa-f82c11c81432/Untitled.png](img/img06/6_linked_list_with_addresses.png)

가장 첫 번째 값인 1은 2의 메모리 주소를, 2는 3의 메모리 주소를 함께 저장

3은 다음 값이 없기 때문에 `NULL(\0, 즉 0으로 채워진 값을 의미)`을 다음 값의 주소로 저장

<br><br>

## **[4) 연결 리스트: 코딩](https://www.boostcourse.org/cs112/lecture/119039?isDesc=false)**

> 배경

    지난 강의에서 연결 리스트의 정의와 리스트의 기본 단위가 되는 구조체를 정의하는 방법을 배웠습니다. 이번 강의에서는 이 구조체를 이용하여 실제로 연결 리스트를 구현하고 사용해보도록 하겠습니다.

> 목표

    연결 리스트를 구현하고 사용

> 키워드

    - 연결 리스트

<br>

> 연결리스트(Linked List) _ Code

```c
#include <stdio.h>
#include <stdlib.h>

//연결 리스트의 기본 단위가 되는 node 구조체를 정의합니다.
typedef struct node
{
    //node 안에서 정수형 값이 저장되는 변수를 name으로 지정합니다.
    int number; 

    //다음 node의 주소를 가리키는 포인터를  *next로 지정합니다.
    struct node *next;
}
node;

int main(void)
{
    // list라는 이름의 node 포인터를 정의합니다. 연결 리스트의 가장 첫 번째 node를 가리킬 것입니다. 
    // 이 포인터는 현재 아무 것도 가리키고 있지 않기 때문에 NULL 로 초기화합니다.
    node *list = NULL;

    // 새로운 node를 위해 메모리를 할당하고 포인터 *n으로 가리킵니다.
    node *n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number 필드에 1의 값을 저장합니다. “n->number”는 “(*n).numer”와 동일한 의미입니다. 
    // 즉, n이 가리키는 node의 number 필드를 의미하는 것입니다. 
    // 간단하게 화살표 표시 ‘->’로 쓸 수 있습니다. n의 number의 값을 1로 저장합니다.
    n->number = 1;

    // n 다음에 정의된 node가 없으므로 NULL로 초기화합니다.
    n->next = NULL;

    // 이제 첫번째 node를 정의했기 떄문에 list 포인터를 n 포인터로 바꿔 줍니다.
    list = n;

    // 이제 list에 다른 node를 더 연결하기 위해 n에 새로운 메모리를 다시 할당합니다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number와 next의 값을 각각 저장합니다.
    n->number = 2;
    n->next = NULL;

    // list가 가리키는 것은 첫 번째 node입니다. 
    //이 node의 다음 node를 n 포인터로 지정합니다.
    list->next = n;

    // 다시 한 번 n 포인터에 새로운 메모리를 할당하고 number과 next의 값을 저장합니다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    n->number = 3;
    n->next = NULL;

    // 현재 list는 첫번째 node를 가리키고, 이는 두번째 node와 연결되어 있습니다. 
    // 따라서 세 번째 node를 더 연결하기 위해 첫 번째 node (list)의 
    // 다음 node(list->next)의 다음 node(list->next->next)를 n 포인터로 지정합니다.
    list->next->next = n;

    // 이제 list에 연결된 node를 처음부터 방문하면서 각 number 값을 출력합니다. 
    // 마지막 node의 next에는 NULL이 저장되어 있을 것이기 때문에 이 것이 for 루프의 종료 조건이 됩니다.
    for (node *tmp = list; tmp != NULL; tmp = tmp->next)
    {
        printf("%i\n", tmp->number);
    }

    // 메모리를 해제해주기 위해 list에 연결된 node들을 처음부터 방문하면서 free 해줍니다.
    while (list != NULL)
    {
        node *tmp = list->next;
        free(list);
        list = tmp;
    }
}
```

<br><br>

## **[5) 연결 리스트: 시연](https://www.boostcourse.org/cs112/lecture/119040?isDesc=false)**

> 배경

    이번 강의에서는 학생들과 함께 연결 리스트를 직접 시현한다. 또 연결 리스트와 배열을 비교해보고 그 장단점을 생각해본다.

> 목표

    연결 리스트와 배열의 장단점을 설명

> 키워드

    - 연결 리스트
    - 배열

<br>

> 연결리스트 vs 배열

연결리스트 - 유동적 구조

- 장점 : 새로운 값을 추가할 때 다시 메모리를 할당하지 않아도 된다
- 단점 : 구조가 정적인 배열과 달리 연결 리스트에서는 임의 접근이 불가능하다.

    → 값을 추가하거나 검색하는 경우 : 해당하는 위치까지 연결 리스트의 각 node들을 따라 이동해야.

    연결 리스트의 크기가 n 일때 그 실행 시간은 O(n)

    배열의 경우 임의 접근이 가능하기 때문에 (정렬 되어 있는 경우) 이진 검색을 이용하면 O(log n)의 실행 시간이 소요 되는 것에 비해서 다소 불리

<br><br>

## **[6) 연결 리스트: 트리](https://www.boostcourse.org/cs112/lecture/119041?isDesc=false)**

> 배경

    연결 리스트를 활용해서 보다 더 다양한 데이터 구조를 만들 수 있다. 연결 리스트에서는 각 요소가 다른 요소를 하나씩만 가리키고 있다. 만약 가리키는 요소가 여러개가 된다면 어떤 장점과 단점이 있을까? 이번 강의에서는 ‘트리’라는 연결 리스트 기반의 자료 구조를 알아본다.

> 목표

    트리의 구조를 설명하고 활용하는 코드를 작성

> 키워드

    - 트리
    - 루트

<br>

> 트리

연결리스트를 기반으로 한 새로운 데이터 구조

노드 : 연결 리스트 내의 한 요소

루트 : 가장 높은 층에서 트리가 시작되는 노드

자식 노드 : 부모노드가 가리키고 있는 다음 층(level)의 노드

연결리스트가 1차원적 연결이라면, 트리는 2차원적 연결

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7a097797-38bc-4408-8f05-f9f5e7a7439a/Untitled.png](img/img06/6_binary_search_tree.png)

이진 검색 트리

- 하나의 노드는 두개의 자식 노드를 가진다.
- 왼쪽 자식노드는 자신의 값보다 작고, 
오른쪽 자식노드는 자신의 값보다 크다.
- 이진 검색을 수행하는데 유리한 구조
- 검색 실행 시간과 노드 삽입 시간은 모두 O(log n)

→ 이진 검색 트리의 노드 구조체와 “50”을 재귀적으로 검색하는 이진 검색 함수

```c
//이진 검색 트리의 노드 구조체
typedef struct node
{
    // 노드의 값
    int number;

    // 왼쪽 자식 노드
    struct node *left;
 
   // 오른쪽 자식 노드
    struct node *right;
} node;

// 이진 검색 함수 (*tree는 이진 검색 트리를 가리키는 포인터)
bool search(node *tree)
{
    // 트리가 비어있는 경우 ‘false’를 반환하고 함수 종료
    if (tree == NULL)
    {
        return false;
    }
    // 현재 노드의 값이 50보다 크면 왼쪽 노드 검색
    else if (50 < tree->number)
    {
        return search(tree->left);
    }
    // 현재 노드의 값이 50보다 작으면 오른쪽 노드 검색
    else if (50 > tree->number)
    {
        return search(tree->right);
    }
    // 위 모든 조건이 만족하지 않으면 노드의 값이 50이므로 ‘true’ 반환
    else {
        return true;
    }
}
```

<br><br>

## **[7) 해시 테이블](https://www.boostcourse.org/cs112/lecture/119042?isDesc=false)**

> 배경

    연결리스트나 트리에서는 값을 검색할 때 O(n) 또는 O(log n)의 시간이 걸렸다. 이 시간을 조금 더 단축해서 거의 O(1)에 가깝게 할 수는 없을까? 이번 강의에서는 이를 가능케 해주는 ‘해시 테이블’ 이라는 자료 구조에 대해 알아본다.

> 목표

    해시 테이블의 원리와 구조를 설명

> 키워드

    - 해시 테이블
    - 해시 함수

<br>

> 해시테이블

연결리스트의 배열

ex) 여러 값들을 몇 개의 바구니에 나눠 담는 상황

각 값들은 `해시 함수`라는 맞춤형 함수를 통해서 어떤 바구니에 담기는 지가 결정된다.

각 바구니에 담기는 값들 → 그 바구니에서 새롭게 정의되는 연결 리스트로 이어진다.

이와 같이 연결 리스트가 담긴 바구니가 여러개 있는 것 = ‘연결 리스트의 배열’, 즉 ‘해시 테이블’

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/34e7cc0a-c640-4d96-9506-4d44531f95e9/Untitled.png](img/img06/6_hash_table.png)

사람의 이름이 해시 테이블에 저장되며, 해시 함수는 `이름의 가장 첫 글자`인 경우

→ 알파벳 개수에 해당하는 총 26개의 포인터들이 있을 수 있으며, 각 포인터는 그 알파벳을 시작으로 하는 이름들을 저장하는 연결 리스트를 가리키게 된다.

만약 해시 함수가 이상적이라면, 각 바구니에는 단 하나의 값들만 담기게 될 것

→ 검색 시간은 `O(1)`이 됩니다.

하지만 그렇지 않은 경우, 최악의 상황에는 단 하나의 바구니에 모든 값들이 담겨서 `O(n)`이 될 수도 있다.

일반적으로는 최대한 많은 바구니를 만드는 해시 함수를 사용하기 때문에 거의 O(1)에 가깝다고 볼 수 있다.

<br><br>

## **[8) 트라이](https://www.boostcourse.org/cs112/lecture/119043?isDesc=false)**

> 배경

    문자열의 길이가 일정한 경우 이 문자열들을 저장하고 관리하는데 최적의 자료 구조는 무엇일까? 
    연결 리스트, 트리, 또는 해시 테이블이 최선의 방안이 될 수 있을까? 
    이번 강의에서는 ‘트라이’라는 자료구조에 대해 알아본다.

> 목표

    트라이의 원리와 구조를 설명

> 키워드

    - 트라이

<br>

> 트라이(tries = retrieval(검색))

어떤 자원을 절약하기 위해 다른 자원을 소비하는 패턴

각 노드가 배열로 구성되어있는 트리

단점 - 많은 메모리 소요

장점 - 자료구조 안에 있는 이름이나 단어를 찾는데 일정한 실행 시간

ex. 영어 알파벳으로 이루어진 문자열 값을 저장하는 경우 (Hermione, Harry, Hagrid 단어를 트라이에 저장)

→ 이 노드는 a부터 z까지의 값을 가지는 배열

그리고 배열의 각 요소, 즉 알파벳은 다음 층의 노드(a-z 배열)를 가리킴

루트 노드를 시작으로 각 화살표가 가리키는 알파벳을 따라가면서 노드를 이어주기

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/964533d1-b571-407c-8076-74e6bffa099c/Untitled.png](img/img06/6_trie.png)

값을 검색하는데 걸리는 시간 :   `문자열의 길이`에 의해 한정된다.

단순히 문자열의 각 문자를 보며 트리를 탐색해나가기만 하면 되기 때문

일반적인 영어 이름의 길이를 `n`이라고 했을 때, 

검색 시간 : `O(n)` <br>
대부분의 이름은 그리 크지 않은 `상수값`(예, 20자 이내)이기 때문에 `O(1)`이나 마찬가지

<br><br>

## **[9) 스택, 큐, 딕셔너리](https://www.boostcourse.org/cs112/lecture/119044?isDesc=false)**

> 배경

    간단하면서 많이 쓰이는 데이터 구조 세 가지(스택, 큐, 딕셔너리)에 대해 알아본다.. 이들은 사실 우리가 이미 여태까지 강의에서 은연중에 다뤘던 구조들이기도 하다. 메모리의 구조에서 잠깐 살펴봤던 ‘스택’과 ‘큐’, 그리고 해시 테이블로 구현할 수 있는 ‘딕셔너리’에 대해 알아본다.

> 목표

    스택, 큐, 딕셔너리의 원리와 구조를 설명

> 키워드

    - 스택
    - 큐
    - 딕셔너리

<br>

> 스택(Stack)

`LIFO(Last In, First Out)` - 후입선출의 방식. 값이 위로 쌓이는 구조. 가장 나중에 들어온 값이 가장 먼저 나감

ex) Gmail 보관함, 뷔페에서 쌓여있는 접시를 가져가는 순서

배열이나 연결 리스트를 통해 구현 가능

- **push** : 어떤 요소를 밀어넣는 것
- **pop** : 가장 위의 요소를 빼는 것

<br>

> 큐(Queue)

`FIFO(First In, First Out)` - 선입선출의 방식. 값이 아래로 쌓이는 구조. 가장 먼저 들어온 값이 가장 먼저 나감

ex) 식당에서의 주문처리, 프린터기 출력순서, 은행에서 줄 선 사람대로 업무 처리

배열이나 연결 리스트를 통해 구현 가능

- **enqueue** : 줄에 들어가서 서는 것
- **dequeue** : 줄을 빠져나오는 것

<br>

> 딕셔너리(Dictionary)

‘키’와 ‘값’이라는 요소로 구성.

‘키’에 해당하는 ‘값’을 저장하고 읽어오는 것

ex) 대학교에서 ‘학번’에 따라서 ‘학생’이 결정되는 것

일반적인 의미에서 ‘해시 테이블’과 동일한 개념

‘키’를 어떻게 정의할 것인지가 중요