# **malloc과 포인터 복습**
### 학습 목표
```
포인터의 개념과 malloc 함수의 용법을 잘 이해할 수 있다.
```

## **1. 오류 파악하기**
아래 코드를 보고 문제가 될 만한 지점이 어디인지 찾아보자.

```c
int main(void)
{
    int *x;
    int *y;

    x = malloc(sizeof(int));

    *x = 42;
    *y = 13;
}
```
- malloc 함수는 할당하고 싶은 크기를 인자로 받는다.
- 의미를 바로 파악하지 못한 부분:  
  `*x = 42`  
  = `x의 주소로 가서 42를 저장해라.`
- 문제가 되는 부분은 *y = 13; 이 부분이다. 위 코드에서 x에는 메모리를 할당해줬는데, y에는 아무런 액션을 취한 것이 없다.
- y는 포인터로는 선언되었는데, 어디를 가리킬지에 대해서는 아직 정의가 되지 않았다.
- 초기화 되지 않은 *y는 프로그램 어딘가를 임의로 가리키고 있을 수 있는데, 그 곳에 13이라는 값을 저장하면 오류를 발생시킬 수가 있다.
- 포인터를 초기화하지 않으면 접근이 허용되지 않는 주소 또는 의도하지 않은 주소를 가리킬 수 있어 예상치 못한 오류가 발생할 수 있다. 그렇기 때문에 프로그래머가 원하는 방식으로 구동되지 않을 수 있다.
<br>
<br>

## **2. 오류 고치기**

```c
y = x;

*y = 13;
```
- y = x; 라는 코드를 넣어주면 y는 x가 가리키는 곳과 같은 곳을 가리키게 된다.
- *y = 13; 코드를 실행하게 되면 x가 가리키는 곳에 13으로 저장이 되기 때문에 42 -> 13으로 덮어써지게 된다.
<br>
<br>
<br>

***
# **배열의 크기 조정하기**
### 학습 목표
```
배열의 크기를 조정하는 코드를 작성할 수 있다.
```

## **1. 배열의 크기 조정**
배열의 크기를 키우려면 어떻게 해야 할지 생각해보자.  

배열의 크기가 3이고, 이 크기를 4로 하고 싶다면 단순히 생각하면 크기가 3인 배열 바로 옆에 한 바이트의 공간만 더 붙이면 된다.  
실제로도 이런 방식으로 배열의 크기를 조정할 수 있을까?  

실제로는 키우려는 배열 메모리 주위에는 다른 메모리들로 둘러 쌓여있을 확률이 높다. 
기존에 사용하고 있던 메모리 뒤에는 다른 데이터들이 담겨 있을 수 있는데 이 상태에서 데이터를 메모리를 새로 할당하지 않고 메모리 크기를 키운다면 뒤에 있던 메모리에 데이터를 덮어쓰는 일이 발생할 수 있다.

따라서 안전하게 새로운 공간에 큰 크기의 메모리를 다시 할당하고 기존 배열의 값들을 하나씩 옮겨줘야 한다.

이런 작업은 배열의 크기 n 만큼 실행 시간이 걸리므로 시간 복잡도는 O(n)이다.
<br>
<br>

## **2. 새로운 메모리 할당**

### **2.1 새로운 공간 만들기**
```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));

    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    int *tmp = malloc(4 * sizeof(int));

    if (tmp == NULL)
    {
        return 1;
    }

    for (int i = 0; i < 3; i++)
    {
        tmp[i] = list[i];
    }


    tmp[3] = 4;


    free(list);


    list = tmp;


    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    free(list);
}
```
- 코드를 읽어보면 다 이해가 가는데, `free(list);` 메모리 해제하는 부분이 아직 헷갈린다. 메모리 공간에서 포인터를 없애는 건지, 할당된 공간 자체를 없애버리는 건지?  
- tmp는 왜 해제를 안하는 거지??

!! 해결되면 어떻게 이해했는지 과정 적고 삭제.
<br>
<br>

### **2.2 realloc**
realloc 함수는 malloc을 통해 할당된 메모리의 크기를 축소하거나 확장하고 싶을 때 사용한다.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *list = malloc(3 * sizeof(int));
    if (list == NULL)
    {
        return 1;
    }

    list[0] = 1;
    list[1] = 2;
    list[2] = 3;

    // tmp 포인터에 메모리를 할당하고 list의 값 복사
    int *tmp = realloc(list, 4 * sizeof(int));
    if (tmp == NULL)
    {
        return 1;
    }

    // list가 tmp와 같은 곳을 가리키도록 지정
    list = tmp;

    // 새로운 list의 네 번째 값 저장
    list[3] = 4;

    // list의 값 확인
    for (int i = 0; i < 4; i++)
    {
        printf("%i\n", list[i]);
    }

    //list 의 메모리 초기화
    free(list);
}
```
- realloc을 사용하니까 list의 값을 tmp로 복사하는 코드를 안적어도 된다.

```c
void* realloc(void* ptr, size_t size);
```
- realloc은 ptr이 가리키는 메모리 주소의 크기를 size 바이트로 확장 또는 축소한다.
<br>
<br>
<br>


***
# **연결리스트: 도입**
### 학습 목표
```
연결 리스트의 정의를 설명할 수 있다.
```
<br>

## **1. 데이터 구조**
기본적인 포인터 구조만 이용해서 메모리를 관리하기에는 다소 번거로울 때가 많다.  

`데이터 구조`는 컴퓨터 메모리를 더 효율적으로 관리하기 위해 새로 정의하는 구조체이다.

쉽게 기억하기 위해, 일종의 메모리 레이아웃 또는 메모리 지도라고 생각하자.
<br>
<br>

## **2. 연결 리스트**
`배열`에서는 각 인덱스의 값이 메모리상에서 연이어 저장되어 있다.  
하지만 다음 인덱스의 값이 메모리상에서 멀리 떨어져 있다면 안되는 걸까?  

각 인덱스 값이 메모리상에 여러 군데 나뉘어져 있다고해도 자기 바로 뒤에 오는 값의 `메모리 주소`만 기억하고 있다면 그 값을 연이어서 읽어들일 수 있다.

이것을 `연결 리스트`라고 한다.

![linked_list](img\linked_list_with_addresses.png)

- 크기가 3인 연결 리스트 이다. 
- 이 연결리스트는 각 인덱스가 메모리 주소에서 `자기 값`이랑 함께 `바로 다음에 오는 값의 주소(포인터)`를 저장한다.
- 연결 리스트의 첫 번째 값인 1은 2의 메모리 주소를 저장하고 있고, 두 번째 값인 2는 3의 메모리 주소를 저장하고 있다.
- 3은 다음에 오는 값이 없기 때문에 NULL을 주소 값으로 저장한다.
<br>
<br>

### **2.1 구조체**
```c
typedef struct node
{
    int number;
    struct node *next;
}
node;
```
- node라는 이름의 구조체에는 number와 *next 필드가 정의되어 있다.
- number는 각 node가 가지는 값, 위의 그림에 나온 크기가 3인 연결리스트에서 1, 2, 3을 말하고, *next는 다음 node를 가리키는 포인터이다.
<br>
<br>

## **3. 배열과 비교했을 때**
- 연결리스트는 다음 값의 주소를 저장하기 때문에 배열과 달리 메모리 상에서 서로 물리적으로 떨어져 있어도 연결이 가능하다.
- 배열은 고정된 갯수만 저장할 수 있는데, 연결 리스트는 필요할 때마다 데이터를 추가, 삭제할 수 있다.
- 연결리스트는 위치를 나타낼 때 인덱스 사용이 불가능하다.
- 원하는 값을 찾을 때까지 포인터를 통해서 노드를 탐색해 나가야하기 때문에 시간이 오래 걸린다.
<br>
<br>
<br>


***
# **연결 리스트: 코딩 그리고 시연**
### 학습 목표
```
연결 리스트를 구현하고 사용할 수 있다.
연결 리스트와 배열의 장단점을 설명할 수 있다.
```

## **1. 코드**
```c
#include <stdio.h>
#include <stdlib.h>

//연결 리스트의 기본 단위가 되는 node 구조체를 정의합니다.
typedef struct node
{
    //node 안에서 정수형 값이 저장되는 변수를 name으로 지정합니다.
    int number; 

    //다음 node의 주소를 가리키는 포인터를  *next로 지정합니다.
    struct node *next;
}
node;

int main(void)
{
    // list라는 이름의 node 포인터를 정의합니다. 연결 리스트의 가장 첫 번째 node를 가리킬 것입니다. 
    // 이 포인터는 현재 아무 것도 가리키고 있지 않기 때문에 NULL 로 초기화합니다.
    node *list = NULL;

    // 새로운 node를 위해 메모리를 할당하고 포인터 *n으로 가리킵니다.
    node *n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number 필드에 1의 값을 저장합니다. “n->number”는 “(*n).numer”와 동일한 의미입니다. 
    // 즉, n이 가리키는 node의 number 필드를 의미하는 것입니다. 
    // 간단하게 화살표 표시 ‘->’로 쓸 수 있습니다. n의 number의 값을 1로 저장합니다.
    n->number = 1;

    // n 다음에 정의된 node가 없으므로 NULL로 초기화합니다.
    n->next = NULL;

    // 이제 첫번째 node를 정의했기 떄문에 list 포인터를 n 포인터로 바꿔 줍니다.
    list = n;

    // 이제 list에 다른 node를 더 연결하기 위해 n에 새로운 메모리를 다시 할당합니다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number와 next의 값을 각각 저장합니다.
    n->number = 2;
    n->next = NULL;

    // list가 가리키는 것은 첫 번째 node입니다. 
    //이 node의 다음 node를 n 포인터로 지정합니다.
    list->next = n;

    // 다시 한 번 n 포인터에 새로운 메모리를 할당하고 number과 next의 값을 저장합니다.
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    n->number = 3;
    n->next = NULL;

    // 현재 list는 첫번째 node를 가리키고, 이는 두번째 node와 연결되어 있습니다. 
    // 따라서 세 번째 node를 더 연결하기 위해 첫 번째 node (list)의 
    // 다음 node(list->next)의 다음 node(list->next->next)를 n 포인터로 지정합니다.
    list->next->next = n;

    // 이제 list에 연결된 node를 처음부터 방문하면서 각 number 값을 출력합니다. 
    // 마지막 node의 next에는 NULL이 저장되어 있을 것이기 때문에 이 것이 for 루프의 종료 조건이 됩니다.
    for (node *tmp = list; tmp != NULL; tmp = tmp->next)
    {
        printf("%i\n", tmp->number);
    }

    // 메모리를 해제해주기 위해 list에 연결된 node들을 처음부터 방문하면서 free 해줍니다.
    while (list != NULL)
    {
        node *tmp = list->next;
        free(list);
        list = tmp;
    }
}
```
- 반드시 그림으로 그려가면서 이해할 것.
- 학생들이 시연했던 장면을 꼭 기억하면서 이해할 것.(포인터가 중요)
<br>
<br>

## **2. 연결 리스트와 배열**
연결 리스트는 새로운 값을 추가할 때 다시 메모리를 할당하지 않아도 된다.  
하지만 이런 유동적인 구조는 그 대가가 따르는데...구조가 정적인 배열과 달리 연결 리스트에서는 `임의 접근`이 `불가능`하다.

연결 리스트에 값을 추가하거나 검색하는 경우를 생각해보자.  
연결 리스트에 값을 추가하기 위해서는 해당하는 위치까지 연결 리스트의 각 node들을 따라 이동해야 했다.  

연결 리스트의 크기가 n일 때 실행 시간은 O(n)이 된다.  
배열의 경우에는 임의 접근이 가능하기 때문에 (물론 정렬 되어있다는 가정하에) 이진 검색을 이용하면 O(log n)의 실행 시간이 소요되는데 이에 비하면 다소 불리하다.

여러 데이터 구조에는 각각 장단점이 존재하므로, 프로그래밍을 할 때 목적에 맞는 가장 효율적인 데이터 구조가 무엇인지 고민하고 생각하면서 사용하는 것이 중요하다.
<br>
<br>
<br>


***
# **연결 리스트: 트리**
```학습 목표
트리의 구조를 설명하고 활용하는 코드를 작성할 수 있다.
```
