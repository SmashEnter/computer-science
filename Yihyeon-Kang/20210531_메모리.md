# **메모리 주소**
### 학습 목표
```
16진법을 읽고 쓸 수 있다.
메모리 주소에 접근하고 값을 받아오는 코드를 C로 작성할 수 있다.
```

## **1. 16진수(Hexadecimal)**
컴퓨터과학에서는 숫자를 10진수나 2진수 대신 16진수로 표현하는 경우가 많다.  
왜???   
당연히 10진수나 2진수 대신 16진수로 표현할 경우에 장점이 있기 때문인데, 그 이유를 알아보자.  
<br>

### **1.1 10진수를 16진수로 바꾸기**
우리가 생활하면서 사용하는 10진수와 16진수를 비교해보면 이유를 바로 알 수 있다.

![16진수와비교](img\compare.png)
- 10진수 255를 2진수로 바꾸면 11111111과 같다.
- 컴퓨터는 2진수를 사용하기 때문에 255를 11111111로 표현해야하지만, 너무 길다.
- 255뿐만 아니라 모든 데이터를 2진수로 표현해야 한다고 가정하면 너무 길어진다.
- 이를 16진수로 한번 표현해보자.
- 11111111를 1111 1111 로 두 덩어리로 나눠서 보면 각 자리 수당 2개(0과 1로 표현)이고 8개의 숫자가 있으니까 16진수로 표현 가능하다.
```
16진수를 표기하는 방법: 
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f
```

### **1.2 16진수의 유용성**
- 10진수 255를 2진수로 표현 하면 11111111이 되고, 10진수 255를 16진수로 표현하면 0xff가 된다. 
- 누가봐도 2진수보다는 16진수로 표현하는 것이 간단해보인다.
- 16진수라는 것을 구별하기 위해 4bits 씩 16진수로 변환한 후 0x를 붙여준다.

## **2. 메모리 주소**
정수형 변수 n에 50을 저장하고 출력해보자.
n은 int 타입이므로 컴퓨터 메모리 어딘가에는 4바이트 만큼 자리를 차지하고 들어가서 저장되어 있을 것이다.

![intN](img\intN.png)

### **2.1 메모리 주소 가져오기**
이 그림을 c언어로 표현해보자.
```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}
```
- `&`: C에서는 변수의 메모리상 주소를 받기 위해 &라는 연산자를 사용할 수 있다.
- 이 코드를 출력해보면 `0x7ffe00b3adbc` 값이 나오는데, 앞에 `0x`를 보고 눈치챌 수 있듯이 16진법으로 표현된 변수 n의 메모리 주소이다.
<br>

### **2.2 메모리 값 가져오기**
```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
```
- `*`를 사용하면 그 메모리 주소에 들어있는 실제 값을 가져올 수 있다.
- 이 코드를 실행해보면 50 이라는 값이 출력된다.
- 먼저 n의 주소를 가져오고, 그 다음에 그 주소에 해당하는 값을 가져와서 출력한 것이다.
<br>
<br>
<br>


***
# **포인터**
### 학습 목표
```
포인터 변수를 정의하고 사용할 수 있다.
```

## **1. `*`**
`&` 연산자는 메모리의 주소를 가져오는 것이고, `*` 연산자는 메모리의 주소에 있는 값을 가져오는 것이라고 배웠다.  
그리고 우리는 이 연산자를 이용해서 `포인터 역할을 하는 변수`를 선언할 수도 있다.

### **1.1 포인터 역할을 하는 변수 선언**
```c
#include <stdio.h>

int main(void)
{
   int n = 50;
   int *p = &n;
   printf("%p\n", p);
   printf("%i\n", *p);
}
```
- int n 에 50이라는 값이 저장 돼있고, n의 주소를 가져 와서 *p 변수에 저장하고 있다.
- 한번도 본 적 없는 게 나왔는데, int *p에서 *는 `이 변수는 포인터 입니다`를 나타내고, int는 이 포인터가 int 타입의 변수를 가리킨다는 의미이다.
- printf("%p\n", p);을 실행하면, 포인터 p의 값, 즉 변수 n의 `주소`를 출력한다.
- printf("%i\n", *p);을 실행하면, 포인터 p가 가리키는 변수의 값, 즉 변수 n의 `값`을 출력한다.
<br>
<br>
<br>


***
# **문자열**
### 학습 목표
```
문자열 형태의 새로운 자료형인 string이 어떻게 정의되었는지 설명할 수 있다.
```
## **1. string의 비밀**
우리는 여태껏 수업을 들으면서 문자열을 저장할 때 CS50 라이브러리에 포함된 string 자료형을 사용했다.
```c
string s = “EMMA”;
```
- 문자열은 결국엔 문자의 배열이다.
- s[0], s[1], s[2]... 이렇게 인덱스 하나로 문자 하나를 나타낸다.
- 사실 변수 s는 이런 문자열을 가리키는 포인터가 된다. 더 자세히 말하자면 문자열 중에서 첫번째 문자, 즉 주소 0x123에 있는 s[0]을 가리킨다.

![s_porinter](img\s_pointer.png)
<br>

## **2. CS50 라이브러리 확인해보기**
실제 CS50 라이브러리에 가서 확인해보면 string 자료형은 이렇게 나와있다.

```c
typedef char *string
```
- 이 부분만 보면 이해가 잘 안갈 수 있으니 밑에 나와있는 두 코드를 비교해보자.

### **2.1 string 자료형을 이용하여 "EMMA" 출력**

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string s = "EMMA";
    printf("%s\n", s);
}
```

### **2.2 char 포인터를 이용하여 "EMMA" 출력**

```c
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%s\n", s);
}
```
<br>
<br>
<br>


***
# **문자열 비교**
### 학습 목표
```
문자열이 저장되어 있는 방식에 근거해서 문자열을 비교하는 방법에 대해 설명할 수 있다.
```

## **1. 예시**
```c
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%p\n", s);
}
```

- 코드를 실행하면?  
  "EMMA" 라는 문자열의 첫번째 값인 "E"의 메모리 주소가 출력이 된다.

```c
printf("%p\n", &s[0]);
printf("%p\n", &s[1]);
printf("%p\n", &s[2]);
printf("%p\n", &s[3]);
```
- 이 코드를 실행하면 어떻게 나올까?
  s라는 문자열의 첫번째 값인 "E"의 메모리 주소, 두번째 값인 "M"의 메모리 주소.....
<br>
<br>

## **2. 문자열 비교**
```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = get_string("t: ");

    if (s == t)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}
```
- 코드를 실행하면?   
  문자열이 저장된 변수 string s와 strign t를 바로 비교하면 변수가 저장되어있는 주소 값이 다르기 때문에 다르다는 결과가 나온다.
- 정확한 비교를 하려면, 실제 문자열이 저장되어있는 곳으로 이동한 후 문자 하나하나씩 비교해야 한다.
<br>
<br>
<br>


***
# **문자열 복사**
### 학습 목표
```
문자열을 복사할 수 있다.
```
<br>

## **1. 문자열 복사**
문자열을 복사하기 위해서 아래 코드를 실행시켜 보자.

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = s;

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```
- string t = s;로 문자열을 복사해놓고 출력을 했다.
- 입력값으로 s: emma 라고 줬을 때, 나오는 출력 값은 둘 다 `Emma`로 나온다.
- s는 emma, t는 EMMA 로 예상했는데, 예상 과는 다른 결과가 나왔다.
- s 변수에는 문자열 emma가 아닌 문자열 emma가 있는 메모리 주소가 저장되기 때문이다.
- t도 마찬가지로 메모리 주소를 가리키고 있고, 이 t를 toupper()로 수정하게 되면 s에도 그대로 반영이 된다.
<br>
<br>

## **2. malloc**
두 문자열을 메모리상에서 복사하려면 어떤 방법을 써야 할까?  

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```

- 못 보던 함수가 나왔다. malloc?   
  malloc 이라는 함수는 정해진 크기 만큼 메모리를 할당하는 함수이다.
- 문자열 s의 길이에서 +1(널 종단 문자)을 한 크기 만큼 메모리를 할당한다.
  예를 들어, emma라는 문자열이라고 한다면, 메모리 크기를 5로 할당한다.
- for문을 돌면서 배열 인덱스를 이용해 s 문자열의 문자 하나하나를 t 문자열로 복사시킨다.
- 이 코드를 실행하면, 우리가 처음에 예상했던 대로 s는 `emma`, t는 `EMMA`가 출력된다. 
<br>
<br>
<br>


***
# **메모리 할당과 해제**
### 학습 목표
```
메모리를 할당하고 해제할 수 있다.
```
<br>

## **1. 메모리 해제**
malloc 함수를 이용하여 정해진 크기만큼 메모리를 할당한 후에는 `free`라는 함수를 이용해서 메모리를 해제해줘야 한다.

### **1.1 메모리를 해제하지 않으면?**
메모리를 해제하지 않으면 메모리에 저장한 값은 쓰레기 값으로 남게 된다.  
이 쓰레기 값들은 메모리 용량을 차지하게 돼서 메모리 낭비가 발생하게 되는데, 이런 현상을 `메모리 누수`라고 한다.

```
help50 valgrind ./filename
```
- valgrind라는 프로그램을 사용하면 지금 내가 작성한 코드에서 메모리 누수가 발생되고 있는지 확인할 수 있다.
<br>
<br>

## **2. 메모리 관련 에러**
이 코드를 실행시켜 보자.

```c
#include <stdlib.h>

void f(void)
{
    int *x = malloc(10 * sizeof(int));
    x[10] = 0;
}

int main(void)
{
    f();
    return 0;
}
```
- f함수를 보면, 우선 malloc(10 * sizeof(int))함수를 살펴보면 10 * 4(int는 4바이트), 40크기의 메모리를 할당한다.
- 다음으로 x의 10번째 인덱스에 0을 할당한다.

- 코드를 실행하고, 이 코드를 valgrind를 써서 확인해보면, `버퍼 오버플로우`, `메모리 누수` 두 가지 에러를 확인할 수 있다.
<br>
<br>

### **2.1 버퍼 오버플로우**
버퍼 오버플로우는 x[10] = 0; 이 코드 때문에 발생한다.  
int *x = malloc(10 * sizeof(int)); 이 코드에서 알 수 있듯이 int 타입으로 10개의 배열을 만들었는데, 이는 0부터 9까지의 인덱스가 있다는 것을 의미한다.  
x[10]에 0을 할당하면 인덱스 10은 11번째 값에 0을 할당하겠다는 의미인데, 11번째에 해당하는 인덱스를 정의하지 않았으므로 `오버 플로우`가 발생한 것이다.  
이 오류는 인덱스를 알맞게 다시 조절하면 해결할 수 있다.
<br>
<br>

### **2.2 메모리 누수**
메모리 누수는 malloc 함수를 이용해 할당한 메모리를 해제하지 않아서 발생한 것이다.  
메모리 누수는 간단하게 free(x)라는 코드를 추가해주면 해결할 수 있다.
<br>
<br>
<br>


***
# **메모리 교환, 스택, 힙**
