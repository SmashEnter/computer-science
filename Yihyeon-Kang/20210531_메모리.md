# **메모리 주소**
### 학습 목표
```
16진법을 읽고 쓸 수 있다.
메모리 주소에 접근하고 값을 받아오는 코드를 C로 작성할 수 있다.
```

## **1. 16진수(Hexadecimal)**
컴퓨터과학에서는 숫자를 10진수나 2진수 대신 16진수로 표현하는 경우가 많다.  
왜???   
당연히 10진수나 2진수 대신 16진수로 표현할 경우에 장점이 있기 때문인데, 그 이유를 알아보자.  
<br>

### **1.1 10진수를 16진수로 바꾸기**
우리가 생활하면서 사용하는 10진수와 16진수를 비교해보면 이유를 바로 알 수 있다.

![16진수와비교](img\compare.png)
- 10진수 255를 2진수로 바꾸면 11111111과 같다.
- 컴퓨터는 2진수를 사용하기 때문에 255를 11111111로 표현해야하지만, 너무 길다.
- 255뿐만 아니라 모든 데이터를 2진수로 표현해야 한다고 가정하면 너무 길어진다.
- 이를 16진수로 한번 표현해보자.
- 11111111를 1111 1111 로 두 덩어리로 나눠서 보면 각 자리 수당 2개(0과 1로 표현)이고 8개의 숫자가 있으니까 16진수로 표현 가능하다.
```
16진수를 표기하는 방법: 
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f
```

### **1.2 16진수의 유용성**
- 10진수 255를 2진수로 표현 하면 11111111이 되고, 10진수 255를 16진수로 표현하면 0xff가 된다. 
- 누가봐도 2진수보다는 16진수로 표현하는 것이 간단해보인다.
- 16진수라는 것을 구별하기 위해 4bits 씩 16진수로 변환한 후 0x를 붙여준다.

## **2. 메모리 주소**
정수형 변수 n에 50을 저장하고 출력해보자.
n은 int 타입이므로 컴퓨터 메모리 어딘가에는 4바이트 만큼 자리를 차지하고 들어가서 저장되어 있을 것이다.

![intN](img\intN.png)

### **2.1 메모리 주소 가져오기**
이 그림을 c언어로 표현해보자.
```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}
```
- `&`: C에서는 변수의 메모리상 주소를 받기 위해 &라는 연산자를 사용할 수 있다.
- 이 코드를 출력해보면 `0x7ffe00b3adbc` 값이 나오는데, 앞에 `0x`를 보고 눈치챌 수 있듯이 16진법으로 표현된 변수 n의 메모리 주소이다.
<br>

### **2.2 메모리 값 가져오기**
```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
```
- `*`를 사용하면 그 메모리 주소에 들어있는 실제 값을 가져올 수 있다.
- 이 코드를 실행해보면 50 이라는 값이 출력된다.
- 먼저 n의 주소를 가져오고, 그 다음에 그 주소에 해당하는 값을 가져와서 출력한 것이다.
<br>
<br>
<br>


***
# **포인터**
### 학습 목표
```
포인터 변수를 정의하고 사용할 수 있다.
```

## **1. `*`**
`&` 연산자는 메모리의 주소를 가져오는 것이고, `*` 연산자는 메모리의 주소에 있는 값을 가져오는 것이라고 배웠다.  
그리고 우리는 이 연산자를 이용해서 `포인터 역할을 하는 변수`를 선언할 수도 있다.

### **1.1 포인터 역할을 하는 변수 선언**
```c
#include <stdio.h>

int main(void)
{
   int n = 50;
   int *p = &n;
   printf("%p\n", p);
   printf("%i\n", *p);
}
```
- int n 에 50이라는 값이 저장 돼있고, n의 주소를 가져 와서 *p 변수에 저장하고 있다.
- 한번도 본 적 없는 게 나왔는데, int *p에서 *는 `이 변수는 포인터 입니다`를 나타내고, int는 이 포인터가 int 타입의 변수를 가리킨다는 의미이다.
- printf("%p\n", p);을 실행하면, 포인터 p의 값, 즉 변수 n의 `주소`를 출력한다.
- printf("%i\n", *p);을 실행하면, 포인터 p가 가리키는 변수의 값, 즉 변수 n의 `값`을 출력한다.
<br>
<br>
<br>


***
# **문자열**
### 학습 목표
```
문자열 형태의 새로운 자료형인 string이 어떻게 정의되었는지 설명할 수 있다.
```
## **1. string의 비밀**
우리는 여태껏 수업을 들으면서 문자열을 저장할 때 CS50 라이브러리에 포함된 string 자료형을 사용했다.
```c
string s = “EMMA”;
```
- 문자열은 결국엔 문자의 배열이다.
- s[0], s[1], s[2]... 이렇게 인덱스 하나로 문자 하나를 나타낸다.
- 사실 변수 s는 이런 문자열을 가리키는 포인터가 된다. 더 자세히 말하자면 문자열 중에서 첫번째 문자, 즉 주소 0x123에 있는 s[0]을 가리킨다.

![s_porinter](img\s_pointer.png)
<br>

## **2. CS50 라이브러리 확인해보기**
실제 CS50 라이브러리에 가서 확인해보면 string 자료형은 이렇게 나와있다.

```c
typedef char *string
```
- 이 부분만 보면 이해가 잘 안갈 수 있으니 밑에 나와있는 두 코드를 비교해보자.

### **2.1 string 자료형을 이용하여 "EMMA" 출력**

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string s = "EMMA";
    printf("%s\n", s);
}
```

### **2.2 char 포인터를 이용하여 "EMMA" 출력**

```c
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%s\n", s);
}
```
<br>
<br>
<br>


***
# **문자열 비교**
### 학습 목표
```
문자열이 저장되어 있는 방식에 근거해서 문자열을 비교하는 방법에 대해 설명할 수 있다.
```

## **1. 예시**
```c
#include <stdio.h>

int main(void)
{
    char *s = "EMMA";
    printf("%p\n", s);
}
```

- 코드를 실행하면?  
  "EMMA" 라는 문자열의 첫번째 값인 "E"의 메모리 주소가 출력이 된다.

```c
printf("%p\n", &s[0]);
printf("%p\n", &s[1]);
printf("%p\n", &s[2]);
printf("%p\n", &s[3]);
```
- 이 코드를 실행하면 어떻게 나올까?
  s라는 문자열의 첫번째 값인 "E"의 메모리 주소, 두번째 값인 "M"의 메모리 주소.....
<br>
<br>

## **2. 문자열 비교**
```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = get_string("t: ");

    if (s == t)
    {
        printf("Same\n");
    }
    else
    {
        printf("Different\n");
    }
}
```
- 코드를 실행하면?   
  문자열이 저장된 변수 string s와 strign t를 바로 비교하면 변수가 저장되어있는 주소 값이 다르기 때문에 다르다는 결과가 나온다.
- 정확한 비교를 하려면, 실제 문자열이 저장되어있는 곳으로 이동한 후 문자 하나하나씩 비교해야 한다.
<br>
<br>
<br>


***
# **문자열 복사**
### 학습 목표
```
문자열을 복사할 수 있다.
```
<br>

## **1. 문자열 복사**
문자열을 복사하기 위해서 아래 코드를 실행시켜 보자.

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>

int main(void)
{
    string s = get_string("s: ");
    string t = s;

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```
- string t = s;로 문자열을 복사해놓고 출력을 했다.
- 입력값으로 s: emma 라고 줬을 때, 나오는 출력 값은 둘 다 `Emma`로 나온다.
- s는 emma, t는 EMMA 로 예상했는데, 예상 과는 다른 결과가 나왔다.
- s 변수에는 문자열 emma가 아닌 문자열 emma가 있는 메모리 주소가 저장되기 때문이다.
- t도 마찬가지로 메모리 주소를 가리키고 있고, 이 t를 toupper()로 수정하게 되면 s에도 그대로 반영이 된다.
<br>
<br>

## **2. malloc**
두 문자열을 메모리상에서 복사하려면 어떤 방법을 써야 할까?  

```c
#include <cs50.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = get_string("s: ");
    char *t = malloc(strlen(s) + 1);

    for (int i = 0, n = strlen(s); i < n + 1; i++)
    {
        t[i] = s[i];
    }

    t[0] = toupper(t[0]);

    printf("s: %s\n", s);
    printf("t: %s\n", t);
}
```

- 못 보던 함수가 나왔다. malloc?   
  malloc 이라는 함수는 정해진 크기 만큼 메모리를 할당하는 함수이다.
- 문자열 s의 길이에서 +1(널 종단 문자)을 한 크기 만큼 메모리를 할당한다.
  예를 들어, emma라는 문자열이라고 한다면, 메모리 크기를 5로 할당한다.
- for문을 돌면서 배열 인덱스를 이용해 s 문자열의 문자 하나하나를 t 문자열로 복사시킨다.
- 이 코드를 실행하면, 우리가 처음에 예상했던 대로 s는 `emma`, t는 `EMMA`가 출력된다. 
<br>
<br>
<br>


***
# **메모리 할당과 해제**
### 학습 목표
```
메모리를 할당하고 해제할 수 있다.
```
<br>

## **1. 메모리 해제**
malloc 함수를 이용하여 정해진 크기만큼 메모리를 할당한 후에는 `free`라는 함수를 이용해서 메모리를 해제해줘야 한다.

### **1.1 메모리를 해제하지 않으면?**
메모리를 해제하지 않으면 메모리에 저장한 값은 쓰레기 값으로 남게 된다.  
이 쓰레기 값들은 메모리 용량을 차지하게 돼서 메모리 낭비가 발생하게 되는데, 이런 현상을 `메모리 누수`라고 한다.

```
help50 valgrind ./filename
```
- valgrind라는 프로그램을 사용하면 지금 내가 작성한 코드에서 메모리 누수가 발생되고 있는지 확인할 수 있다.
<br>
<br>

## **2. 메모리 관련 에러**
이 코드를 실행시켜 보자.

```c
#include <stdlib.h>

void f(void)
{
    int *x = malloc(10 * sizeof(int));
    x[10] = 0;
}

int main(void)
{
    f();
    return 0;
}
```
- f함수를 보면, 우선 malloc(10 * sizeof(int))함수를 살펴보면 10 * 4(int는 4바이트), 40크기의 메모리를 할당한다.
- 다음으로 x의 10번째 인덱스에 0을 할당한다.

- 코드를 실행하고, 이 코드를 valgrind를 써서 확인해보면, `버퍼 오버플로우`, `메모리 누수` 두 가지 에러를 확인할 수 있다.
<br>
<br>

### **2.1 버퍼 오버플로우**
버퍼 오버플로우는 x[10] = 0; 이 코드 때문에 발생한다.  
int *x = malloc(10 * sizeof(int)); 이 코드에서 알 수 있듯이 int 타입으로 10개의 배열을 만들었는데, 이는 0부터 9까지의 인덱스가 있다는 것을 의미한다.  
x[10]에 0을 할당하면 인덱스 10은 11번째 값에 0을 할당하겠다는 의미인데, 11번째에 해당하는 인덱스를 정의하지 않았으므로 `오버 플로우`가 발생한 것이다.  
이 오류는 인덱스를 알맞게 다시 조절하면 해결할 수 있다.
<br>
<br>

### **2.2 메모리 누수**
메모리 누수는 malloc 함수를 이용해 할당한 메모리를 해제하지 않아서 발생한 것이다.  
메모리 누수는 간단하게 free(x)라는 코드를 추가해주면 해결할 수 있다.
<br>
<br>
<br>


***
# **메모리 교환, 스택, 힙**
### 학습 목표
```
메모리에 저장된 두 값을 교환하는 코드를 작성할 수 있다.
```

## **1. 값 교환하기**
a와 b의 값을 입력 받고 두 값을 교환하는 코드를 출력해보자.

```c
#include <stdio.h>

void swap(int a, int b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(x, y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int a, int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

- swap 함수를 통해 두 값이 교환 될 것이란 걸 기대할 수 있다.
- 출력해보면?  
  나의 예상과는 다르게 x와 y가 바꿔지지 않고 그대로 출력된다.
- swap 함수가 제대로 작동되지 않은 게 아니라, swap 함수는 교환 작업이 제대로 일어났는데 문제는 또 메모리 구조를 잘 몰라서 발생한 것이다.
<br>
<br>

## **2. 메모리 구조 이해하기**

![memory_layout](img\memory_layout.png)

- 메모리 안에는 데이터 저장 구역이 나뉘어져있다.
- 머신 코드 영역에는 프로그램이 실행될 때 그 프로그램이 컴파일된 바이너리가 저장된다.
- 글로벌 영역에는 프로그램 안에서 저장된 전역 변수가 저장된다.
- `힙` 영역에는 malloc으로 할당된 메모리 데이터가 저장된다.
- `스택` 영역에는 프로그램 내의 함수와 관련된 것들이 저장된다.
- 코드에서 변수 x, y, tmp, a, b는 모두 스택 영역에 저장되는데, 그 안에서도 서로 다른 위치에 저장 됐다.
<br>
<br>

### **2.1 문제 해결하기**
![pointer](img\pointers.png)

- 이 그림처럼 a와 b를 각각 x와 y를 가리키는 포인터로 지정하면 문제를 해결할 수 있다.

```c
#include <stdio.h>

void swap(int *a, int *b);

int main(void)
{
    int x = 1;
    int y = 2;

    printf("x is %i, y is %i\n", x, y);
    swap(&x, &y);
    printf("x is %i, y is %i\n", x, y);
}

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```
<br>
<br>
<br>


***
# **파일 쓰기**
### 학습 목표
```
사용자로부터 값을 입력받아 파일에 출력하는 프로그램을 작성할 수 있다.
```

## **1. 힙 오버플로우, 스택 오버플로우**
![memory_layout](img\memory_layout.png)

- 힙 영역에서 계속 malloc을 호출하게 되면 화살표 방향(아래방향)으로 메모리를 계속 사용하게 된다.
- 스택 영역에서는 함수가 많이 호출되면 될수록 사용하는 메모리 범위가 점점 위로 늘어나게 된다.
- 이렇게 힙과 스택 영역에서 계속해서 늘어나다 보면 메모리 용량은 제한되어있기 때문에 두 메모리 영역이 어디선가 충돌하게 된다.
- 이 같은 현상을 `힙 오버플로우` 또는 `스택 오버플로우`라고 말한다.
<br>
<br>

## **2. 사용자에게 입력 받기**
스택은 get_int, get_string 같은 함수에서도 사용된다.
get_int, get_string 함수를 직접 구현해보자.
<br>

### **2.1 get_int**
```c
#include <stdio.h>

int main(void)
{
    int x;
    printf("x: ");
    scanf("%i", &x);
    printf("x: %i\n", x);
}
```
- int x를 정의한 후에 scanf에 x가 아니라 &x로 주소를 입력해줬다.
- scanf 함수의 변수가 실제로 스택 영역 안에 x가 저장돼있는 주소로 찾아가서 사용자가 입력한 갑을 저장하도록 하기 위해서이다. 


### **2.2 get_string**
```c
#include <stdio.h>

int main(void)
{
    char s[5];
    printf("s: ");
    scanf("%s", s);
    printf("s: %s\n", s);
}
```
- scanf함수에 &s가 아니라 s를 그대로 입력해줬다.
- s는 크기가 5인 char 자료형의 배열로 정의 했기 때문이다.
- clang 컴파일러는 문자 배열의 이름을 포인터처럼 다루기 때문에 scanf에 s라는 배열의 첫 바이트 주소를 넘겨주는 것이다.

### **2.3. scanf**

- scanf 함수는 C언어의 표준 입력 함수로, 사용자로부터 다양한 데이터를 다양한 서식에 맞춰 입력 받을 수 있게 해준다.  
scanf() 함수의 f는 formatted의 약자이며, 서식화된 입력을 받는다는 의미이다.
<br>
<br>

## **3. 파일 쓰기**
사용자로부터 입력 받아서 파일에 저장하는 프로그램을 만들어보자.

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    FILE *file = fopen("phonebook.csv", "a");
    char *name = get_string("Name: ");
    char *number = get_string("Number: ");
    fprintf(file, "%s,%s\n", name, number);
    fclose(file);
}
```
- fopen이라는 함수를 이용하면 FILE 이라는 자료형을 불러올 수 있다.
- fopen 함수의 첫번째 인자는 파일 이름, 두 번째 인자는 모드를 일컫는데, 모드 r은 reading 읽기, w는 writing 쓰기, a는 append 덧붙이기를 의미한다.
- printf처럼 fprintf 함수를 이용해서 파일에 직접 내용을 출력하자.
<br>
<br>
<br>


***
# **파일 읽기**
### 학습 목표
```
파일을 읽고 JPEG 파일인지를 검사하는 프로그램을 작성할 수 있다.
```
<br>

## **1. 파일 읽기**
파일의 내용을 읽어서 파일 형식이 JPEG 이미지인지 검사하는 프로그램을 만들어보자.

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        return 1;
    }

    FILE *file = fopen(argv[1], "r");

    if (file == NULL)
    {
        return 1;
    }
 
   unsigned char bytes[3];
    fread(bytes, 3, 1, file);

    if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
    {
        printf("Maybe\n");
    }
    else
    {
        printf("No\n");
    }
    fclose(file);
}
```
- main 함수를 보면 void가 아닌 사용자로부터 입력 받는 값이 있다는 것을 알 수 있다.
- argc가 2라고 가정하고 코드를 진행해보자.   
입력받은 파일명 argv[1]을 읽기모드로 불러온다.
- 파일이 열렸다면 `fread(bytes, 3, 1, file);` 함수를 실행하는데, fread(배열, 읽을 바이트 수, 읽을 횟수, 읽을 파일)을 의미한다.
- 읽어들인 각 바이트가 0xFF, 0xD8, 0xFF 인지를 확인하는데, 이는 개발자가 JPEG 형식의 파일을 정의할 때 만든 약속(`파일 시그니처`)이므로, JPEG 파일의 시작점에 포함되어 있어야 한다.

