# **컴파일링**
### 학습목표
```
컴파일링의 네 단계를 설명할 수 있다.
```
<br>

## **1. 동작원리**
이전에 사용한 예제 코드를 다시 보면서 동작 원리를 이해해보자.

### **1.1**
```c
#include <stdio.h>

int main(void)
{
    printf("hello, world\n");
}
```
-   main 함수를 만나서 프로그램을 시작한다.
-   printf 함수를 수행해야 하는데, 그러려면 stdio.h 라이브러리가 필요하다. stdio.h 라이브러리에 대해 좀 더 자세히 알아보자.
-   stdio.h는 헤더 파일이고 C언어로 작성되어 있으며 파일 확장자가 .h로 끝난다.
-   stdio.h 파일에는 printf 함수의 프로토타입이 있어서 Clang 컴파일러가 프로그램을 컴파일 할 때 printf가 무엇인지 알려준다.

### **1.2**

- clang hello.c로 컴파일하고 그 결과 a.out 이라는 머신코드가 만들어지면 ./a.out 명령으로 프로그램을 실행한다. 
- a.out 파일은 컴퓨터가 이해할 수 있는 0과 1로 만들어졌기 때문에 프로그램이 실행 가능하다.

### **1.3**

```c
clang -o hello hello.c
```
-   의미없어보이는 a.out 이라는 파일명 대신 다른 이름(hello)으로 컴파일 하고 싶을 때 사용하는 명령어이다.

### **1.4**
  
```c
clnag -o hello hello.c -lcs50
```
-   stdio.h 말고 CS50 라이브러리도 사용해봤었는데 CS50 라이브러리를 사용한 프로그램을 컴파일 할 때는 
 clang에 또 다른 프로그램(-lcs50)이 필요했다.
-   clang에게 CS50 라이브러리에 있는 모든 0과 1을 여기에 연결하라는 의미이다.
-   조금 번거로운 이 과정들을 좀 간단히 하기 위해 우리는 make 프로그램을 이용하여 모든 컴파일 과정을 자동으로 처리했다.

<br>

## **2. 컴파일링의 네 단계**
make나 clang을 사용해서 프로그램을 실행하면 네 단계를 거치게 된다.
이 과정에서 어떤 일이 일어나는지 알아보자.
<br>
<br>

### **1. 전처리(Precompile)**
- 전처리기에 의해 수행된다.
- `#` 으로 시작되는 C 소스 코드는 전처리기에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려준다.
- 예를 들어, `#include`는 전처리기에게 다른 파일의 내용을 포함시키라고 알려준다.  
프로그램의 소스코드에 #include와 같은 줄을 포함하면, 전처리기는 새로운 파일을 생성하는데 이 파일은 여전히 C 소스 코드 형태이며, stdio.h 파일의 내용이 #include 부분에 포함된다.
<br>
<br>

### **2. 컴파일(Compile)**
- 전처리기가 전처리한 소스 코드를 생성하고 나면 그 다음 단계는 `컴파일`이다.
- `컴파일러`라고 불리는 프로그램은 C 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일 한다.
- `어셈블리`는 C보다 연산의 종류가 훨씬 적지만, 여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것들을 수행할 수 있다.
- C 코드를 어셈블리 코드로 변환시켜줌으로써 컴파일러는 컴퓨터가 이해할 수 있는 언어와 최대한 가까운  프로그램으로 만들어준다.
- 컴파일이라는 용어는 소스 코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 일컫기도 하지만, 구체적으로 전처리한 소스 코드를 어셈블리 코드로 변환시키는 단계를 말하기도 한다.
<br>
<br>

### **3. 어셈블(Assemble)**
- 소스 코드가 어셈블리 코드로 변환되면, 다음 단계는 `어셈블` 단계로 어셈블리 코드를 오브젝트 코드로 변환시키는 것이다.
- 컴퓨터의 중앙처리장치(CPU)가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 0과 1들로 바꿔주는 작업을 말한다.
- 이 변환작업은 `어셈블러`라는 프로그램이 수행한다.
- 소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 딱 한 개라면, 컴파일 작업은 여기서 끝이난다.  
그러나 그렇지 않은 경우에는 링크라 불리는 단계가 추가된다.
<br>
<br>

### **4. 링크(Link)**
- 만약 프로그램이 (math.h나 cs50.h와 같은 라이브러리를 포함해) `여러 개`의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 `링크`라는 컴파일의 마지막 단계가 필요하다.
- 링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐준다.
- 예를 들어, 컴파일을 하는 동안에 CS50 라이브러리를 링크하면 오브젝트 코드는 GetInt()나 GetString() 같은 함수를 어떻게 실행할 지 알 수 있게 된다.
- 이 네 단계를 거치면 최종적으로 실행 가능한 파일이 완성된다.
<br>
<br>
<br>


***
# **디버깅**
### 학습목표
```
디버깅 하는 여러 방법을 설명할 수 있다.
```

## **1. 버그와 디버깅**
### **1.1 버그**
- 버그는 코드에 들어있는 오류이다.  
- 버그로 인해 프로그램 실행에 실패하거나 프로그래머가 원하는대로 동작하게 하는 데 실패한다.

### **1.2 디버깅**
- 코드에 있는 버그를 식별하고 고치는 과정을 말한다.
- `디버거`라고 불리는 프로그램을 사용하여 디버깅을 하게 된다.
- 디버거는 프로그램을 특정 행에서 멈출 수 있게 해주기 때문에 버그를 찾는 데 도움이 된다.
- 프로그램이 멈추는 특정 지점을 break point(중지점)라고 한다.
- 프로그래머가 프로그램을 한번에 한 행씩 실행할 수 있게 해주므로 프로그램이 수행되는 과정들을 단계별로 파악하는 것이 가능하다.
<br>
<br>
<br>



***
# **배열**
### 학습목표
```
배열을 정의하고 사용하는 방법을 설명할 수 있다.
```

## **1. 메모리**
C에는 다음과 같은 여러 자료형이 있고, 각각의 자료형은 서로 다른 크기의 메모리를 갖는다.
```
bool: 1byte
char: 1byte
int: 4byte
float: 4byte
long: 8byte
double: 8byte
string: ?byte
```
컴퓨터에서는 RAM이라는 물리적 칩이 메모리 역할을 한다.

![RAM](img\ram.png)
- 쉽게 생각하면 위 사진에 나와있는 조그만 여러 개의 노란색 사각형이 메모리를 의미하고, 작은 사각형 하나는 1바이트를 의미한다.
<br>
<br>

## **2. 배열**
배열은 같은 자료형의 데이터를 메모리상에 연속으로 저장하고 이를 하나의 변수로 관리하기 위해 사용된다.

```c
#include <cs50.h>
#include <stdio.h>

int main(void)
{
    // Scores
    int scores[3];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // Print average
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / 3);
}
```
- int scores[3]; 을 보자. int 자료형, 크기는 3, 변수명은 scores라는 배열을 만들겠다는 의미이다.
- 배열의 인덱스는 0부터 시작하기 때문에 첫 인덱스는 1, 2, 3이 아닌 0, 1, 2 이다.
<br>
<br>

## **3. 전역 변수**
배열의 크기를 정해주는 N 이라는 변수를 새로 선언한 코드를 살펴보자.
```c
#include <cs50.h>
#include <stdio.h>

const int N = 3;

int main(void)
{
    // 점수 배열 선언 및 값 저장
    int scores[N];
    scores[0] = 72;
    scores[1] = 73;
    scores[2] = 33;

    // 평균 점수 출력
    printf("Average: %i\n", (scores[0] + scores[1] + scores[2]) / N);
}
```
- N이 고정된 값(상수) 이라면 값을 선언할 때 const를 붙여준다. 전역 변수라는 의미인데 코드 전반에 거쳐 바뀌지 않는 값임을 뜻한다.
- N의 값을 5라고 지정한다면, scores[3], scores[4]를 선언하고 값을 저장해줘야 하는 번거로움이 남아있다.
<br>
<br>

## **4. 배열의 동적 선언 및 저장**
루프와 함수를 선언하여 좀 더 동적인 코드를 작성해보자.
```c
#include <cs50.h>
#include <stdio.h>

float average(int length, int array[]);

int main(void)
{
    // 사용자로부터 점수의 갯수 입력
    int n = get_int("Scores:  ");

    // 점수 배열 선언 및 사용자로부터 값 입력
    int scores[n];
    for (int i = 0; i < n; i++)
    {
        scores[i] = get_int("Score %i: ", i + 1);
    }

    // 평균 출력
    printf("Average: %.1f\n", average(n, scores));
}

//평균을 계산하는 함수
float average(int length, int array[])
{
    int sum = 0;
    for (int i = 0; i < length; i++)
    {
        sum += array[i];
    }
    return (float) sum / (float) length;
}
```
<br>
<br>
<br>




***
# **문자열과 배열**
### 학습목표
```
문자열이 C에서 정의되는 방식과 메모리에 저장되는 방식을 설명할 수 있다.
```

## **1. 문자열?**
문자열(string) 자료형의 데이터는 문자(char) 자료형의 데이터들의 배열이다.  
```
string s = "HI!";
```
문자열 s는 문자의 배열이기 때문에 메모리상에 아래의 그림과 같이 저장된다.

![memoryWithString](img\memory_with_string.png)
- 인덱스로 각 문자에 접근이 가능하다.
- s[0] = H
- s[1] = I
- s[2] = !
- s[3] = \0
- 3번째 인덱스의 '\0' 은 문자열의 끝을 나타내는 null 종단 문자이다.
<br>
<br>
<br>


***
# **문자열의 활용**
### 학습목표
```
문자열을 탐색하고 일부 문자를 수정하는 코드를 구현할 수 있다.
```

## **1. 문자열 탐색**
- 사용자로부터 문자열을 입력받아 한 글자씩 출력하는 코드를 짜야 한다면 간단하게 for문을 이용해 문자열의 인덱스를 1씩 증가시켜나가면 된다.
<br>
<br>

### **1.1 문자열이 끝나는 인덱스는 어떻게 알 수 있을까?**
1. 해당 인덱스의 문자가 null 종단 문자와 일치하는지 검사하면 된다.
    ```c
    for (int i = 0; s[i] != ‘\0’; i++) 
    { 
        ...
    } 
    ```
    <br>

2. strlen() 함수를 사용하면 된다.
   
    ```c
    #include <cs50.h>
    #include <stdio.h>
    #include <string.h>

    int main(void)
    {
        string s = get_string("Input: ");
        printf("Output:\n");
        for (int i = 0, n = strlen(s); i < n; i++)
        {
            printf("%c\n", s[i]);
        }
    }
    ```
 - strlen은 문자열의 길이를 알려주는 함수이다. (string.h 라이브러리 안에 포함돼있다.)
 - 일일이 null 종단 문자인지 검사하는 것보다 훨씬 효율적이다.
 <br>
 <br>


## **2. 문자열 수정**
사용자로부터 문자열을 입력받았다고 가정하고 이 문자열을 대문자로 바꿔주는 코드를 작성해보자.

```c
#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
    string s = get_string("Before: ");
    printf("After:  ");
    for (int i = 0, n = strlen(s); i < n; i++)
    {
        if (s[i] >= 'a' && s[i] <= 'z')
        {
            printf("%c", s[i] - 32);
        }
        else
        {
            printf("%c", s[i]);
        }
    }
    printf("\n");
}
```

- 사용자에게 문자를 입력받고 이 문자가 'a'보다 크고 'z'보다 작은지 검사한다.(소문자인지 검사)
- 문자 간 대소비교가 가능한 이유는 ASCII 코드를 떠올려보자.
- 대문자 A는 65, B는 66 ....
- ASCII 표를 보면 알파벳 소문자와 대문자 간은 숫자 32만큼 차이가 나는 것을 확인할 수 있다.
- 따라서 알파벳 소문자는 `그 소문자 - 32`를 계산하면 그 연산 결과 값에 해당하는 대문자가 나온다. 
- 이와 동일한 작업을 수행하는 toupper() 함수도 참고해서 살펴보자. (ctype 라이브러리에 있다.)
  
    ```c
    #include <cs50.h>
    #include <ctype.h>
    #include <stdio.h>
    #include <string.h>

    int main(void)
    {
        string s = get_string("Before: ");
        printf("After:  ");
        for (int i = 0, n = strlen(s); i < n; i++)
        {
            printf("%c", toupper(s[i]));
        }
        printf("\n");
    }
    ```
    <br>
    <br>
    <br>