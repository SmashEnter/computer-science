# **검색 알고리즘**
### 학습 목표
```
주어진 배열 속에서 특정 값을 찾는 방법을 설명할 수 있다.
```

## **0. 인트로**
- 배열은 한 자료형의 여러 값들이 메모리상에 모여 있는 구조이다. 컴퓨터는 이 값들에 접근할 때 배열의 인덱스 하나하나에 접근한다.  
만약 어떤 값이 배열 안에 속해 있는지를 찾아보려면 배열이 정렬되어 있는지의 여부에 따라 다른 방법을 사용할 수 있다.

## **1. 선형 검색**
- 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검사하는 것이다.
- 케비넷에서 숫자 50을 찾기 위해 Eric이 첫번째 사물함부터 마지막 사물함까지 문을 하나씩 차례대로 열어봤던 장면을 떠올려보자.

## **2. 이진 검색**
- 배열이 정렬되어 있다면, 배열의 중간 인덱스부터 시작해서 찾으려고 하는 값과 비교하여 그 값보다 작은 값이 저장되어 있는 인덱스 혹은 큰 값이 저장되어 있는 인덱스 쪽으로 이동하고 이를 반복한다.
- 숫자가 정렬 돼있는 상태에서, Nizari가 가운데 사물함을 열었을 때 나온 숫자와 숫자 50을 비교하여 왼쪽 사물함을 열어볼지 오른쪽 사물함을 열어볼지 선택하고 이 과정을 반복했던 장면을 떠올려보자. 
<br>
<br>
<br>


***
# **알고리즘 표기법**
### 학습 목표
```
알고리즘 실행 시간의 상한과 하한을 표기할 수 있다.
```

## **1. Big O 표기법**
알고리즘을 실행하는 데 걸리는 시간은 아래 그림과 같다.

![bigO](img\running_time.png)

이 그림을 공식으로 표기한 것이 Big O 표기법이다.
- O 는 "on the order of"의 약자이고, 쉽게 생각하면 "~만큼의 정도로 커지는" 것이라고 볼 수 있다.
- O(n)은 n만큼 커지는 것이므로 n이 커지면 선형적으로 증가한다.
- O(n/2)도 결국 n이 매우 커지면 1/2은 큰 의미가 없어지므로 O(n)이라고 볼 수 있다.
  - 예를 들어, 우리가 푸는 문제가 계속 커져서 저 선들을 더 큰 화면에 담기도록 축소해서 보기 위해 x축과 y축을 늘려보자. 노란 선과 빨간 선은 아주 가까워질 것이고, 계속 축소하다보면 두 선은 결국 거의 같아 보일 것이다.
<br>
<br>
<br>

### **1.1. 해당 알고리즘**
  
|Big O|검색 알고리즘|
|-|-|
|O(n^2)||
|O(n)|선형 검색|
|O(log n)|이진 검색|
|O(1)||

<br>
<br>

## **2. Big Ω**
Big O가 알고리즘 실행 시간의 상한을 나타낸 것이라면 Big Ω는 알고리즘 실행 시간의 하한을 나타내는 것이다.

### **2.1. 해당 알고리즘**
  
|Big Ω|검색 알고리즘|
|-|-|
|Ω(n^2)||
|Ω(n log n)||
|Ω(n)|배열 안에 존재하는 값의 개수 세기|
|Ω(log n)||
|Ω(1)|선형 검색, 이진 검색|

<br>
<br>
  

***
# **선형 검색**
### 학습 목표
```
주어진 배열 또는 구조체에서 선형 검색을 할 수 있다.
```

## **1. 선형 검색**
- 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색하는 것.
- 이처럼 선형 검색은 찾고자 하는 자료를 찾을 때까지 모든 자료를 확인해야 한다.
- 자료가 정렬되어 있지 않거나 그 어떤 정보도 없어서 하나씩 찾아야 하는 경우에 유용  
<br>
<br>
<br>


***
# **버블 정렬**
### 학습 목표
```
버블 정렬의 원리와 실행 시간을 설명하고 구현할 수 있다.
```


# **선택 정렬**
# **정렬 알고리즘의 실행시간**
# **재귀**
# **병합 정렬**