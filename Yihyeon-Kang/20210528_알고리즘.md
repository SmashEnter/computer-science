# **검색 알고리즘**
### 학습 목표
```
주어진 배열 속에서 특정 값을 찾는 방법을 설명할 수 있다.
```

## **0. 인트로**
- 배열은 한 자료형의 여러 값들이 메모리상에 모여 있는 구조이다. 컴퓨터는 이 값들에 접근할 때 배열의 인덱스 하나하나에 접근한다.  
만약 어떤 값이 배열 안에 속해 있는지를 찾아보려면 배열이 정렬되어 있는지의 여부에 따라 다른 방법을 사용할 수 있다.

## **1. 선형 검색**
- 배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지를 검사하는 것이다.
- 케비넷에서 숫자 50을 찾기 위해 Eric이 첫번째 사물함부터 마지막 사물함까지 문을 하나씩 차례대로 열어봤던 장면을 떠올려보자.

## **2. 이진 검색**
- 배열이 정렬되어 있다면, 배열의 중간 인덱스부터 시작해서 찾으려고 하는 값과 비교하여 그 값보다 작은 값이 저장되어 있는 인덱스 혹은 큰 값이 저장되어 있는 인덱스 쪽으로 이동하고 이를 반복한다.
- 숫자가 정렬 돼있는 상태에서, Nizari가 가운데 사물함을 열었을 때 나온 숫자와 숫자 50을 비교하여 왼쪽 사물함을 열어볼지 오른쪽 사물함을 열어볼지 선택하고 이 과정을 반복했던 장면을 떠올려보자. 
<br>
<br>
<br>


***
# **알고리즘 표기법**
### 학습 목표
```
알고리즘 실행 시간의 상한과 하한을 표기할 수 있다.
```

## **1. Big O 표기법**
알고리즘을 실행하는 데 걸리는 시간은 아래 그림과 같다.

![bigO](img\running_time.png)

이 그림을 공식으로 표기한 것이 Big O 표기법이다.
- O 는 "on the order of"의 약자이고, 쉽게 생각하면 "~만큼의 정도로 커지는" 것이라고 볼 수 있다.
- O(n)은 n만큼 커지는 것이므로 n이 커지면 선형적으로 증가한다.
- O(n/2)도 결국 n이 매우 커지면 1/2은 큰 의미가 없어지므로 O(n)이라고 볼 수 있다.
  - 예를 들어, 우리가 푸는 문제가 계속 커져서 저 선들을 더 큰 화면에 담기도록 축소해서 보기 위해 x축과 y축을 늘려보자. 노란 선과 빨간 선은 아주 가까워질 것이고, 계속 축소하다보면 두 선은 결국 거의 같아 보일 것이다.
<br>
<br>
<br>

### **1.1. 해당 알고리즘**
  
|Big O|검색 알고리즘|
|-|-|
|O(n^2)||
|O(n)|선형 검색|
|O(log n)|이진 검색|
|O(1)||

<br>
<br>

## **2. Big Ω**
Big O가 알고리즘 실행 시간의 상한을 나타낸 것이라면 Big Ω는 알고리즘 실행 시간의 하한을 나타내는 것이다.

### **2.1. 해당 알고리즘**
  
|Big Ω|검색 알고리즘|
|-|-|
|Ω(n^2)||
|Ω(n log n)||
|Ω(n)|배열 안에 존재하는 값의 개수 세기|
|Ω(log n)||
|Ω(1)|선형 검색, 이진 검색|

<br>
<br>
  

***
# **선형 검색**
### 학습 목표
```
주어진 배열 또는 구조체에서 선형 검색을 할 수 있다.
```

## **1. 선형 검색**
- 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색하는 것.
- 이처럼 선형 검색은 찾고자 하는 자료를 찾을 때까지 모든 자료를 확인해야 한다.
- 자료가 정렬되어 있지 않거나 그 어떤 정보도 없어서 하나씩 찾아야 하는 경우에 유용  
<br>
<br>
<br>


***
# **버블 정렬**
### 학습 목표
```
버블 정렬의 원리와 실행 시간을 설명하고 구현할 수 있다.
```

## **1. 정렬 알고리즘**
- 정렬되지 않은 리스트를 탐색하느 것보다 정렬한 뒤 탐색하는 것이 더 효율적이다.
- 정렬 알고리즘 중 하나인 버블 정렬은 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법을 말한다.
  

## **2. 예시**
숫자 8개가 임의의 순서로 나열 되어 있다.
```
6 3 8 5 2 7 4 1
```
이 숫자들을 오름차순으로 정렬하기 위해 버블 정렬을 이용해보자.
- `3 6` 8 5 2 7 4 1
- 3 6 `5 8` 2 7 4 1
- 바로 다음에 있는 숫자와 비교해서 정렬을 해나가면 아래와 같이 정렬이 된다.
- `3 6 5 2 7 4 1 8`
- 오름차순으로 정렬이 되지 않았기 때문에 다시 처음으로 돌아가서 같은 작업을 반복한다.
- `3 5 2 6 4 1 7 8`
- 조금 더 정렬된 모습이지만 완벽히 정렬되지 않았으므로 다시 반복하자.
- `1 2 4 3 5 6 7 8`
<br>
<br>
<br>


***
# **선택 정렬**
### 학습 목표
```
선택 정렬의 원리와 실행 시간을 설명하고 구현할 수 있다.
```

## **1. 정렬 알고리즘**
- 정렬 알고리즘 중 하나인 선택 정렬은 배열 안에 나열된 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬이다.
- 선택 정렬은 교환 횟수를 최소화하지만 각 자료를 비교하는 횟수는 증가한다.

## **2. 예시**
정렬되지 않은 숫자 8개가 있다. 이 숫자들을 오름차순으로 정렬해보자.
```
6 3 8 5 2 7 4 1
```
- 숫자들을 끝까지 탐색하면서 제일 작은 수를 찾는다.
- 6 3 8 5 2 7 4 `1`
- 가장 작은 값과 현재 리스트의 첫 번째 값을 교환한다.
- `1` 3 8 5 2 7 4 `6`
- 1은 이제 정렬이 되어 있으니 제외하고, 두 번째 숫자부터 탐색하면서 또 제일 작은 수를 찾는다.
- 1 3 8 5 `2` 7 4 6
- 1 `2` 8 5 `3` 7 4 6
- 교환이 일어나지 않을 때까지 반복한다.
- `1 2 3 4 5 6 7 8`
<br>
<br>
<br>


***
# **정렬 알고리즘의 실행시간**
### 학습 목표
```
여러 정렬 알고리즘과 검색 알고리즘의 실행 시간을 Big O와 Big Ω로 정의할 수 있다.
```

## **1. 실행시간 정리**
### **1.1 실행시간의 상한**
```
O(n^2): 선택 정렬, 버블 정렬  
O(n log n)  
O(n): 선형 검색  
O(log n): 이진 검색  
O(1)  
```
<br>

### **1.2 실행시간의 하한**
```
Ω(n^2): 선택 정렬
Ω(n log n)
Ω(n): 버블 정렬
Ω(log n)
Ω(1): 선형 검색, 이진 검색
```
<br>
<br>
<br>


***
# **재귀**
### 학습 목표
```
함수를 재귀적으로 사용하는 코드를 작성할 수 있다.
```

## **1. 재귀?**
- main에서 필요할 때 다른 함수들을 호출해서 사용했던 상황을 떠올려 보자. 생각해보면 main도 함수인데 main이라는 함수 안에서 다른 함수를 호출해서 사용한 것이다.
- 그렇다면 함수가 본인 스스로를 호출해서 사용할 수 있을까?
  -> YES. 이를 `재귀(Recursion)`라고 부른다.
<br>
<br>

## **2. 피라미드를 출력하자**
```
#

##

###

####
```

```c
#include <cs50.h>
#include <stdio.h>

void draw(int h);

int main(void)
{
    int height = get_int("Height: ");

    draw(height);
}

void draw(int h)
{
    // 높이가 0이라면 (그릴 필요가 없다면)
    if (h == 0)
    {
        return;
    }

    // 높이가 h-1인 피라미드 그리기
    draw(h - 1);

    // 피라미드에서 폭이 h인 한 층 그리기
    for (int i = 0; i < h; i++)
    {
        printf("#");
    }
    printf("\n");
}
```
- draw 함수 안에서 draw 함수를 다시 호출하는 부분을 유의해서 보자.
- h라는 높이를 받았을 때, h-1 높이로 draw 함수를 먼저 호출하고, 그 후에 h 만큼의 #을 출력한다.  
여기서 내부적으로 호출된 draw 함수를 따라가다 보면 h = 0인 상황이 오게 되는데 이때는 아무것도 출력을 하지 않도록 하는 조건문을 추가해줘야 한다.
- 피라미드 4층 짜리는 사실 피라미드 3층 + 1층 추가 해준 것이라는 설명을 떠올리며 기억하자.
<br>
<br>
<br>



***
# **병합 정렬**
### 학습 목표
```
재귀를 활용한 병합 정렬을 구현할 수 있다.
```

## **1. 정렬 알고리즘**
- 대표적인 정렬방법 중 하나이다.
- 전화번호부에서 mike를 찾기 위해 절반을 나눠서 탐색해나갔던 분할 정복 탐색처럼 데이터를 반으로 나누어간다는 공통점이 있다.
- 병합 정렬은 원소가 한 개가 될 때까지 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식이다.

## **2. 예시**
임의로 나열된 8개의 숫자를 오름차순으로 정렬해보자.
```
7 4 5 2 6 3 8 1
```
- 먼저 숫자를 반으로 나누자.
- `7 4 5 2` | `6 3 8 1`
- 나눠 놓은 덩어리를 한번 더 나눠보자.
- `7 4` | `5 2` | 6 3 8 1
- 또 나누자.
- `7` | `4` | 5 2 | 6 3 8 1
- 원소가 한 개가 남았으므로 더 이상 나눌 수가 없다. 두 숫자를 작은 숫자가 먼저 오도록 병합하자.
- `4 7` | 5 2 | 6 3 8 1
- 5 2 부분도 같은 방법으로 병합하자.
- 4 7 | `2 5` | 6 3 8 1
- 4 7 과 2 5 부분도 병합하자. 앞에서부터 순서대로 읽어서 비교하고 더 작은 숫자를 가져오자. 
2와 4를 비교해서 2를 가져오고, 그 후에 4와 5를 비교해서 4를 가져오고, 그 후에 7과 5를 비교해서 5를 가져오고, 남아 있는 7을 가져온다.
- `2 4 5 7` | 6 3 8 1
- 오른쪽 4개 숫자들도 동일한 작업을 반복하자.
- 2 4 5 7 | `1 3 6 8`
- 마찬가지로 1과 2를 비교해서 1을 가져오고, 그 후에 2와 3을 비교해서 2를 가져온다. 그 후에 4와 3을 비교해서 3을 가져오고, 4와 6을 비교 후 4를 가져오고, 5와 6 비교 후 5를 가져오고...
- `1 2 3 4 5 6 7 8`